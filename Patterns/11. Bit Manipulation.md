# Bit Manipulation — Step-by-Step Mastery Guide

---
## 1. Master the 6 Core Bit Manipulation Patterns

| Pattern                      | Example Problem              | Key Idea                                     |
| ---------------------------- | ---------------------------- | -------------------------------------------- |
| 1. Bitwise Counting / Parity | Single Number, XOR of Array  | XOR to find unique or odd-count element      |
| 2. Bit Masking & Subsets     | Subsets, DP with Masking     | Each bit in mask → include/exclude           |
| 3. Checking / Flipping Bits  | Power of Two, Count Set Bits | Use shifting and masking to isolate bits     |
| 4. Lowest Set Bit Tricks     | Brian Kernighan’s Algorithm  | x & (x−1), x & (−x), etc.                    |
| 5. Bit DP                    | TSP, Max XOR Subsets         | DP[state][position] where state is a bitmask |
| 6. Trie + Bitmask (Advanced) | Maximum XOR Pair             | Build trie based on bits of numbers          |

---

## 2. Ask These When You Suspect a Bit Problem

1. Can this number be represented by a bitmask?    
2. Can XOR help track parity or uniqueness?
3. Are we generating all subsets? (Try 0 to 2^n mask loop)
4. Am I checking powers of 2, on/off status of bits?

---

## 3. Must-Know Problems by Pattern

|Problem|Pattern|Key Insight|
|---|---|---|
|1. Single Number (LC 136)|Bitwise XOR|XOR cancels out duplicates|
|2. Single Number II (LC 137)|Bitwise Count|Count bits in 32 pos & mod 3|
|3. Subsets (LC 78)|Bit Masking|Each mask represents a subset|
|4. Count Set Bits (LC 191)|Set Bit Tricks|Brian Kernighan’s x & (x−1)|
|5. Power of Two (LC 231)|Bit Check|x & (x−1) == 0 for powers of 2|
|6. Reverse Bits (LC 190)|Bit Shifting|Build new int bit by bit|
|7. Maximum XOR (LC 421)|Trie + Bitmask|Greedily pick opposite bit|
|8. Total Hamming Distance|Bitwise Count|Count 1s at each position|
|9. Maximum Product of Word Lengths|Bitmask Set|Represent each word with 26-bit mask|
|10. DP TSP with Bitmask|Bit DP|dp[mask][u]: min cost visiting mask ending at u|

---

## 4. Code Templates to Know

🟩 1. Check if ith bit is set  

```cpp
if (num & (1 << i)) {
    // ith bit is set
}
```

🟩 2. Count number of set bits (Brian Kernighan’s Algorithm)

```cpp
int countSetBits(int n) {
    int count = 0;
    while (n) {
        n &= (n - 1); // drops the lowest set bit
        count++;
    }
    return count;
}
```

🟩 3. Generate all subsets using bitmask

```cpp
vector<vector<int>> subsets(vector<int>& nums) {
    int n = nums.size();
    vector<vector<int>> res;
    for (int mask = 0; mask < (1 << n); ++mask) {
        vector<int> subset;
        for (int i = 0; i < n; ++i)
            if (mask & (1 << i)) subset.push_back(nums[i]);
        res.push_back(subset);
    }
    return res;
}
```

🟩 4. XOR Trick (Finding Unique Number)

```cpp
int singleNumber(vector<int>& nums) {
    int xorSum = 0;
    for (int x : nums) xorSum ^= x;
    return xorSum;
}
```

🟩 5. Power of Two

```cpp
bool isPowerOfTwo(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}
```

🟩 6. Bitmask DP (TSP example)

```cpp
int tsp(int mask, int pos, vector<vector<int>>& dist, vector<vector<int>>& dp) {
    if (mask == (1 << dist.size()) - 1) return dist[pos][0]; // All visited
    if (dp[mask][pos] != -1) return dp[mask][pos];
    
    int ans = INT_MAX;
    for (int city = 0; city < dist.size(); ++city) {
        if ((mask & (1 << city)) == 0) {
            int newAns = dist[pos][city] + tsp(mask | (1 << city), city, dist, dp);
            ans = min(ans, newAns);
        }
    }
    return dp[mask][pos] = ans;
}
```

---

## 5. Weekly Bit Manipulation Practice Plan

📅 Week 1 — Build the Basics

| Day   | Task                                                                       |
| ----- | -------------------------------------------------------------------------- |
| Day 1 | XOR: Single Number, Single Number II                                       |
| Day 2 | Count Set Bits, Power of Two, Bit Reverse                                  |
| Day 3 | Subsets via Bitmask, Hamming Distance                                      |
| Day 4 | Max Product Word Lengths (bit + string)                                    |
| Day 5 | Max XOR Pair (Trie + Greedy)                                               |
| Day 6 | TSP with Bitmask DP                                                        |
| Day 7 | Reflect, and write custom utility: print binary, set ith bit, toggle, etc. |

---

## 6. Tips for Success

✅ When trying to generate all subsets or combinations → use mask from 0 to 2n − 1  
✅ Use (x & (x−1)) to remove lowest set bit  
✅ Use (x & −x) to isolate lowest set bit  
✅ Bitmasks are great for “states” — especially in DP or constraint selection  
✅ XOR is your best friend for problems involving exactly 1 or 2 unique elements

---
