# Mathematics ‚Äî Step-by-Step Mastery Guide
---
## 1. Core Patterns in Mathematics for DSA

| Pattern                | Example Problem                      | Key Idea                                                  |
| ---------------------- | ------------------------------------ | --------------------------------------------------------- |
| 1. Prime Sieve         | Count Primes, Segmented Sieve        | Precompute primes up to N in O(N log log N)               |
| 2. GCD & LCM           | LCM, Reduce Fractions, Coprime Count | GCD(a,b) = GCD(b, a % b); LCM = a √ó b / GCD               |
| 3. Modular Arithmetic  | Modular Inverse, Factorials Modulo   | (a + b) % m, (a √ó b) % m, Fermat's for inverse if m prime |
| 4. Fast Exponentiation | Power(a, b) % m                      | Binary Exponentiation in O(log b)                         |
| 5. Combinatorics       | nCr, Catalan, DP + Math              | Count subsets, sequences, partitions                      |

---

## 2. Questions to Ask Before Applying Math

1. Can I precompute values (primes, factorials, inverses)?
2. Is the input size large (e.g., compute mod 1e9+7)?
3. Are divisors or co-primes involved?
4. Does the problem ask for ‚Äúways‚Äù, ‚Äúcombinations‚Äù, ‚Äúarrangements‚Äù?

---

## 3. Must-Know Problems by Pattern

|Problem|Pattern|Must-Learn Idea|
|---|---|---|
|1. Count Primes (LC 204)|Sieve of Eratosthenes|Mark all multiples starting from p √ó p|
|2. GCD of Strings (LC 1071)|GCD|If a + b == b + a ‚Üí GCD(lenA, lenB)|
|3. LCM Triplet Max|GCD + LCM|Use GCD(a, b) and LCM = a√ób / GCD|
|4. Modular Exponentiation|Fast Power|a^b % m in O(log b)|
|5. Power of Large Numbers|Fast Power + Mod|Recursive mod exponent with nested power|
|6. Modular Inverse|Fermat / Extended Euclid|a^-1 ‚â° a^(m‚àí2) mod m (if m is prime)|
|7. nCr % p|Combinatorics|Precompute fact[n] and inv_fact[n]|
|8. Catalan Number|DP + Combinatorics|Cn = (2n)! / ((n+1)!¬∑n!)|
|9. Count Ways to Tile/Arrange|Combinatorics + Rec|DP[i] = DP[i‚àí1] + DP[i‚àí2] (tiling 2√ón)|
|10. Number of Divisors|Prime Factorization|Product of (ei + 1) over all prime powers|

---

## 4. Code Templates

üü© 1. Sieve of Eratosthenes (Primes ‚â§ N)  

```cpp
vector<bool> isPrime(N+1, true);
isPrime[0] = isPrime[1] = false;
for (int i = 2; i * i <= N; ++i) {
    if (isPrime[i]) {
        for (int j = i * i; j <= N; j += i)
            isPrime[j] = false;
    }
}
```

üü© 2. GCD & LCM

```cpp
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
int lcm(int a, int b) {
    return a / gcd(a, b) * b;
}
```

üü© 3. Modular Exponentiation (a^b % mod)

```cpp
long long power(long long a, long long b, long long mod) {
    long long res = 1;
    a %= mod;
    while (b > 0) {
        if (b & 1) res = (res * a) % mod;
        a = (a * a) % mod;
        b >>= 1;
    }
    return res;
}
```

üü© 4. Modular Inverse using Fermat‚Äôs Little Theorem  
(only when mod is prime)

```cpp
int modInverse(int a, int mod) {
    return power(a, mod - 2, mod);
}
```

üü© 5. nCr % mod using precomputed factorials  

```cpp
const int N = 1e6 + 5;
int mod = 1e9 + 7;
vector<long long> fact(N), invFact(N);

void precompute() {
    fact[0] = invFact[0] = 1;
    for (int i = 1; i < N; ++i)
        fact[i] = (fact[i - 1] * i) % mod;
    invFact[N - 1] = modInverse(fact[N - 1], mod);
    for (int i = N - 2; i > 0; --i)
        invFact[i] = (invFact[i + 1] * (i + 1)) % mod;
}

long long nCr(int n, int r) {
    if (r > n || r < 0) return 0;
    return fact[n] * invFact[r] % mod * invFact[n - r] % mod;
}
```

---

## 5. Mini Weekly Math Practice Plan

üìÖ Week 1 ‚Äî Core Building

|Day|Task|
|---|---|
|Day 1|Sieve of Eratosthenes + Count Primes|
|Day 2|GCD, LCM, GCD of Strings|
|Day 3|Modular Exponentiation + Fast Power|
|Day 4|Modular Inverse + Large Power Calculations|
|Day 5|nCr % mod + Precompute Factorials|
|Day 6|Divisor Count + Prime Factor Count|
|Day 7|Practice 2 problems from Codeforces/LC involving modular math|

---

## 6. Pro Tips

‚úÖ Always use 1LL √ó for multiplication in C++ to avoid overflow  
‚úÖ For factorial-based problems with mod, always precompute factorials and modular inverses  
‚úÖ For GCD-related constraints, try reducing the problem using GCD  
‚úÖ Use Sieve when answering multiple prime-related queries  
‚úÖ Modular inverse only works with primes using Fermat. For non-prime mods, use Extended Euclid.
