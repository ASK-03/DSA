# Linked List â€” Step-by-Step Mastery Guide

---
## 1. Master the 5 Core Linked List Patterns

| Pattern                       | Example Problem                        | Key Idea                                                 |
| ----------------------------- | -------------------------------------- | -------------------------------------------------------- |
| 1. Reverse in K-groups        | Reverse Nodes in k-Group (LC 25)       | Count nodes in group, reverse recursively or iteratively |
| 2. Detect Cycle               | Linked List Cycle (LC 141/142)         | Use Floydâ€™s Tortoise & Hare (slow/fast pointers)         |
| 3. Merge Sort on List         | Sort List (LC 148)                     | Find middle with slow/fast, recurse + merge              |
| 4. Clone with Random Pointers | Copy List with Random Pointer (LC 138) | Interleave copy nodes + adjust randoms + split           |
| 5. Intersection Node          | Intersection of Two Lists (LC 160)     | Two-pointer reset trick to sync traversal length         |

---

## 2. Ask These Before Solving Linked List Problems

1. Do I need to reverse, split, or merge the list?    
2. Am I allowed to use extra space?
3. Is the list cyclic or contains special pointers (random)?
4. Do I need to maintain order or structure?

---

## 3. Must-Know Problems (and why)

|Problem|Pattern|What You Learn|
|---|---|---|
|1. Reverse Nodes in K-Group (LC 25)|K-Reversal|Reverse chunks of K using recursion|
|2. Linked List Cycle I & II (LC 141/142)|Cycle Detection|Detect loop & find entry point|
|3. Sort List (LC 148)|Merge Sort|Merge sort on linked list|
|4. Copy List with Random Pointer (LC 138)|Clone Random|Interleave trick to copy without map|
|5. Intersection of Two Lists (LC 160)|Intersection Node|Sync pointer traversal length|
|6. Remove Nth Node from End (LC 19)|Two-Pointer|Use gap of N between fast/slow|
|7. Palindrome Linked List (LC 234)|Middle + Reverse|Reverse second half and compare|
|8. Add Two Numbers (LC 2)|Linked List Math|Simulate digit-by-digit addition|
|9. Reorder List (LC 143)|Middle + Reverse|Merge first half with reversed second|
|10. Flatten Multilevel List (LC 430)|Recursive Flatten|DFS + tail tracking|

---

## 4. Code Templates You Must Know

ðŸŸ© 1. Reverse K-Group  
```cpp
ListNode* reverseKGroup(ListNode* head, int k) {
    ListNode* curr = head;
    int count = 0;
    while (curr && count < k) {
        curr = curr->next;
        count++;
    }
    if (count < k) return head;

    // Reverse first k nodes
    ListNode* prev = nullptr;
    curr = head;
    for (int i = 0; i < k; ++i) {
        ListNode* next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }

    head->next = reverseKGroup(curr, k); // Recursively reverse next
    return prev;
}
```

ðŸŸ© 2. Detect Cycle (Floydâ€™s Algorithm)

```cpp
bool hasCycle(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) return true;
    }
    return false;
}
```

ðŸŸ© 3. Merge Sort on Linked List

```cpp
ListNode* sortList(ListNode* head) {
    if (!head || !head->next) return head;
    ListNode* slow = head, *fast = head->next;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    ListNode* mid = slow->next;
    slow->next = nullptr;
    ListNode* left = sortList(head);
    ListNode* right = sortList(mid);
    return merge(left, right);
}

ListNode* merge(ListNode* l1, ListNode* l2) {
    ListNode dummy, *tail = &dummy;
    while (l1 && l2) {
        if (l1->val < l2->val) {
            tail->next = l1; l1 = l1->next;
        } else {
            tail->next = l2; l2 = l2->next;
        }
        tail = tail->next;
    }
    tail->next = l1 ? l1 : l2;
    return dummy.next;
}
```

ðŸŸ© 4. Clone with Random Pointers

```cpp
Node* copyRandomList(Node* head) {
    if (!head) return nullptr;

    // Step 1: Interleave cloned nodes
    Node* curr = head;
    while (curr) {
        Node* copy = new Node(curr->val);
        copy->next = curr->next;
        curr->next = copy;
        curr = copy->next;
    }

    // Step 2: Assign random pointers
    curr = head;
    while (curr) {
        if (curr->random)
            curr->next->random = curr->random->next;
        curr = curr->next->next;
    }

    // Step 3: Separate two lists
    Node* dummy = new Node(0);
    Node* copy = dummy;
    curr = head;
    while (curr) {
        copy->next = curr->next;
        curr->next = curr->next->next;
        copy = copy->next;
        curr = curr->next;
    }
    return dummy->next;
}
```

ðŸŸ© 5. Intersection Node (Length Sync Trick)

```cpp
ListNode* getIntersectionNode(ListNode* a, ListNode* b) {
    ListNode* p1 = a, *p2 = b;
    while (p1 != p2) {
        p1 = p1 ? p1->next : b;
        p2 = p2 ? p2->next : a;
    }
    return p1;
}
```

---

## 5. Weekly Linked List Practice Plan

ðŸ“… Week 1 â€” Classic Linked List Mastery

| Day   | Task                                          |
| ----- | --------------------------------------------- |
| Day 1 | Reverse List + Reverse in K-Groups            |
| Day 2 | Detect Cycle I & II (with entry point)        |
| Day 3 | Merge Sort on Linked List                     |
| Day 4 | Clone with Random Pointers                    |
| Day 5 | Intersection Node + Remove Nth Node           |
| Day 6 | Reorder List + Palindrome List                |
| Day 7 | Reflection: draw all pointer changes on paper |

---

## 6. Tips for Success

âœ… Always use dummy nodes when modifying list heads  
âœ… Trace slow & fast pointers with pen/paper  
âœ… For clone problems, donâ€™t jump to hashmap â€” try O(1) space solutions  
âœ… Use recursion cautiously in large lists to avoid stack overflow  
âœ… Practice debugging pointer changes line by line
