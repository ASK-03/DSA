# Segment Tree / Fenwick Tree â€” Step-by-Step

---
## 1. Core Patterns in Segment & Fenwick Trees

| Pattern                     | Example Problem                   | Key Idea                                        |
| --------------------------- | --------------------------------- | ----------------------------------------------- |
| 1. Range Sum / Min / Max    | LC 307, RMQ, Range Max Query      | Build tree in O(N), Query/Update in O(log N)    |
| 2. Lazy Propagation         | Range Update & Query (Codeforces) | Delay updates until needed, use lazy[] array    |
| 3. 2D BIT / 2D Segment Tree | LC 308, Range Sum over Matrix     | Extend BIT or Segment Tree to handle 2D queries |
| 4. Persistent Segment Tree  | Kth Order Statistic in Versions   | Save version roots, share unchanged segments    |

---

## 2. Ask These Before Using a Tree

1. Are there frequent range queries or updates?    
2. Are updates point or range based?
3. Is the array static or does it evolve (â†’ Persistent)?
4. Is it 1D or 2D data?

---

## 3. Must-Know Problems by Pattern

| Problem                             | Pattern                 | What You Learn                              |
| ----------------------------------- | ----------------------- | ------------------------------------------- |
| 1. Range Sum Query (LC 307)         | Segment Tree            | Build, update, and query ranges             |
| 2. 2D Range Sum Query (LC 308)      | 2D BIT                  | Extend prefix logic with 2D index trick     |
| 3. Range Update, Range Query        | Lazy Propagation        | Push delayed updates to children            |
| 4. Count Inversions                 | BIT or Merge Sort       | Fenwick Tree to count inversions            |
| 5. Kth Order Statistic (Codeforces) | Persistent Segment Tree | Build on past versions                      |
| 6. Range Minimum Query (RMQ)        | Segment Tree            | Min segment propagation                     |
| 7. Dynamic Range GCD, Max, XOR      | Segment Tree            | Track any operation by combining logic      |
| 8. Rectangle Sum on Matrix          | 2D Segment Tree         | Query sub-matrix sum                        |
| 9. Update Intervals (Range Add)     | BIT + Trick             | Use range trick: BIT[r+1] -= x, BIT[l] += x |

---

## 4. Code Templates

ðŸŸ© 1. Segment Tree (Range Sum)  

```cpp
int seg[4 * N];

void build(int idx, int l, int r, int a[]) {
    if (l == r) {
        seg[idx] = a[l];
        return;
    }
    int mid = (l + r) / 2;
    build(2*idx, l, mid, a);
    build(2*idx+1, mid+1, r, a);
    seg[idx] = seg[2*idx] + seg[2*idx+1];
}

void update(int idx, int l, int r, int pos, int val) {
    if (l == r) {
        seg[idx] = val;
        return;
    }
    int mid = (l + r) / 2;
    if (pos <= mid) update(2*idx, l, mid, pos, val);
    else update(2*idx+1, mid+1, r, pos, val);
    seg[idx] = seg[2*idx] + seg[2*idx+1];
}

int query(int idx, int l, int r, int ql, int qr) {
    if (qr < l || r < ql) return 0;
    if (ql <= l && r <= qr) return seg[idx];
    int mid = (l + r) / 2;
    return query(2*idx, l, mid, ql, qr) + query(2*idx+1, mid+1, r, ql, qr);
}
```

ðŸŸ© 2. Fenwick Tree (1-based Index)

```cpp
int bit[N+1];

void update(int i, int x) {
    while (i <= N) {
        bit[i] += x;
        i += (i & -i);
    }
}

int query(int i) {
    int sum = 0;
    while (i > 0) {
        sum += bit[i];
        i -= (i & -i);
    }
    return sum;
}

int rangeSum(int l, int r) {
    return query(r) - query(l-1);
}
```

ðŸŸ© 3. Lazy Propagation (Range Update + Query)

```cpp
int seg[4*N], lazy[4*N];

void push(int idx, int l, int r) {
    if (lazy[idx]) {
        seg[idx] += (r - l + 1) * lazy[idx];
        if (l != r) {
            lazy[2*idx] += lazy[idx];
            lazy[2*idx+1] += lazy[idx];
        }
        lazy[idx] = 0;
    }
}

void update(int idx, int l, int r, int ql, int qr, int val) {
    push(idx, l, r);
    if (qr < l || r < ql) return;
    if (ql <= l && r <= qr) {
        lazy[idx] += val;
        push(idx, l, r);
        return;
    }
    int mid = (l + r) / 2;
    update(2*idx, l, mid, ql, qr, val);
    update(2*idx+1, mid+1, r, ql, qr, val);
    seg[idx] = seg[2*idx] + seg[2*idx+1];
}

int query(int idx, int l, int r, int ql, int qr) {
    push(idx, l, r);
    if (qr < l || r < ql) return 0;
    if (ql <= l && r <= qr) return seg[idx];
    int mid = (l + r) / 2;
    return query(2*idx, l, mid, ql, qr) + query(2*idx+1, mid+1, r, ql, qr);
}
```

ðŸŸ© 4. 2D Fenwick Tree

```cpp
int bit[H+1][W+1];

void update(int x, int y, int delta) {
    for (int i = x; i <= H; i += i & -i) {
        for (int j = y; j <= W; j += j & -j)
            bit[i][j] += delta;
    }
}

int query(int x, int y) {
    int res = 0;
    for (int i = x; i > 0; i -= i & -i) {
        for (int j = y; j > 0; j -= j & -j)
            res += bit[i][j];
    }
    return res;
}

int rangeSum(int x1, int y1, int x2, int y2) {
    return query(x2,y2) - query(x1-1,y2) - query(x2,y1-1) + query(x1-1,y1-1);
}
```

ðŸŸ© 5. Persistent Segment Tree (Functional Style)  
Use pointers to save different versions â€” only nodes on the path are copied.  
Pseudocode:

```cpp
struct Node {
    int val;
    Node *left, *right;
    Node(int v) : val(v), left(nullptr), right(nullptr) {}
};

Node* build(int l, int r) {
    Node* node = new Node(0);
    if (l == r) return node;
    int m = (l + r) / 2;
    node->left = build(l, m);
    node->right = build(m+1, r);
    return node;
}

Node* update(Node* prev, int l, int r, int pos, int val) {
    Node* node = new Node(prev->val);
    if (l == r) {
        node->val += val;
        return node;
    }
    int m = (l + r) / 2;
    if (pos <= m) {
        node->left = update(prev->left, l, m, pos, val);
        node->right = prev->right;
    } else {
        node->left = prev->left;
        node->right = update(prev->right, m+1, r, pos, val);
    }
    node->val = node->left->val + node->right->val;
    return node;
}

int query(Node* node, int l, int r, int ql, int qr) {
    if (!node || qr < l || ql > r) return 0;
    if (ql <= l && r <= qr) return node->val;
    int m = (l + r) / 2;
    return query(node->left, l, m, ql, qr) + query(node->right, m+1, r, ql, qr);
}
```

---

## 5. ðŸ“… Weekly Practice Plan

ðŸ“… Week 1 â€” Mastering Range Query Data Structures

| Day   | Task                                            |
| ----- | ----------------------------------------------- |
| Day 1 | Build & query Segment Tree (Range Sum)          |
| Day 2 | Fenwick Tree basics (update + prefix)           |
| Day 3 | Lazy Propagation for range updates              |
| Day 4 | Count Inversions with BIT                       |
| Day 5 | 2D BIT for matrix sum                           |
| Day 6 | Persistent Segment Tree with versions           |
| Day 7 | Practice Codeforces/AtCoder segment tree rounds |

---

## 6. Tips for Success

âœ… Prefer BIT if you only need prefix sums  
âœ… Use Segment Tree when needing range min/max/gcd/xor  
âœ… Persistent Segment Trees = powerful for versioning/k-th queries  
âœ… Lazy propagation is key when frequent range updates occur  
âœ… Always watch 1-based vs 0-based indexing (especially in BIT!)
