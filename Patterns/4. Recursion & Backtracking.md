
## Step-By-Step Approach
---
### 1. **Master the 6 Core Backtracking Patterns**

| Pattern                      | Example Problem                  | Key Idea                                          |
| ---------------------------- | -------------------------------- | ------------------------------------------------- |
| 1. Subsets / Powersets       | Subsets I & II (LC 78, 90)       | Include/Exclude each element (tree structure)     |
| 2. Permutations              | Permutations I & II (LC 46, 47)  | Swap or pick used elements with visited tracking  |
| 3. Combination Generation    | Combination Sum, N-Choose-K      | Pick next number from current or ahead            |
| 4. Valid Configuration       | N-Queens, Sudoku Solver          | Backtrack only on valid moves                     |
| 5. Palindromic Decomposition | Palindrome Partitioning (LC 131) | Explore only if current cut is a palindrome       |
| 6. Constraint Solver         | Word Search, Rat in a Maze       | DFS + Mark/Unmark cell + Explore all 4 directions |

---

### 2. **Ask These When Solving Recursion/Backtracking Problems**

1. **What is the decision at each step?**
2. **What is the base case? When do I stop?**
3. **Do I need to prune invalid paths?**
4. **Am I building a path (vector), and should I undo changes before backtracking?**

---

### 3. **Must-Know Problems You Should Master**

|Problem|Pattern|Must-Learn Idea|
|---|---|---|
|1. Subsets|Subset Tree|Include/Exclude|
|2. Subsets II|Handle Duplicates|Sort + skip dup|
|3. Permutations|Pick each unused|Track visited[]|
|4. Permutations II|Handle duplicates|Sort + visited + skip dup|
|5. Combination Sum I/II|Choose multiple or unique|Loop + backtrack|
|6. N-Queens|Constraint Grid|Is safe + backtrack|
|7. Sudoku Solver|Constraint Grid|Cell validity|
|8. Palindrome Partitioning|Palindrome Check|Recursive cuts|
|9. Word Search|DFS Backtracking|Cell visit with direction|
|10. Letter Combinations (Phone)|Map digits to chars|Build all combos|

---

### 4. **Code Template for Generic Backtracking**

```cpp
void backtrack(vector<int>& nums, int start, vector<int>& path, vector<vector<int>>& result) {
    // Base case
    result.push_back(path);

    for (int i = start; i < nums.size(); ++i) {
        // Optional: Skip duplicates or check constraints
        path.push_back(nums[i]);
        backtrack(nums, i + 1, path, result);  // Recursive call
        path.pop_back();  // Undo choice (Backtrack)
    }
}
```

---

### 5. **Mini Plan to Build Intuition**

#### 📅 Week 1 — Recursive Exploration

|Day|Task|
|---|---|
|Day 1|Subsets I & II|
|Day 2|Permutations I & II|
|Day 3|Combination Sum I & II|
|Day 4|Palindrome Partitioning + Letter Combinations|
|Day 5|N-Queens + Sudoku Solver|
|Day 6|Word Search + Rat in Maze|
|Day 7|Reflect: What patterns did you repeat? Build your base template|

---

### 6. **Tips for Success**

✅ Always remember to **undo your choice after recursion (pop_back, unmark)**  
✅ **Use sorting + skip logic** for avoiding duplicate permutations or subsets  
✅ For **grids**, combine with **DFS** and mark cells as visited  
✅ For **combinations**, pass `i+1` to avoid reusing same elements  
✅ For **palindrome questions**, **validate before recursive cut**

---

### 🔍 How to Spot a Backtracking Problem:

- Problem asks: **“Return all combinations / permutations / ways”**
- It involves: **choice → explore → undo**
- There's usually: **a constraint to prune paths**

---