## Step-By-Step Approach

---

### 1. Core Graph Patterns (You Must Master)

These are the foundational tools that cover 90%+ of graph problems in coding interviews.

| Pattern                   | Example Problem                         | Key Idea                             |
| ------------------------- | --------------------------------------- | ------------------------------------ |
| 1. BFS (Shortest Path)    | Word Ladder, Nearest Exit in Maze       | Queue-based level order, min # steps |
| 2. DFS (Backtrack/Search) | Number of Islands, Connected Components | Recursive exploration                |
| 3. Topological Sort       | Course Schedule, Alien Dictionary       | Linear ordering for DAG              |
| 4. Dijkstra's Algorithm   | Network Delay Time, Path with Min Cost  | Weighted shortest path with PQ       |
| 5. Bellman-Ford           | Detect Negative Cycles                  | N‚àí1 edge relaxations + cycle check   |
| 6. Union-Find (DSU)       | Redundant Connection, Graph Valid Tree  | Component merging, detect cycles     |
| 7. Minimum Spanning Tree  | Kruskal's, Prim‚Äôs Algorithm             | Build cheapest spanning connection   |
| 8. Tarjan‚Äôs Algorithms    | Bridges, SCCs in Directed Graph         | Low-link values, time tracking       |
| 9. Floyd-Warshall         | All-Pairs Shortest Paths                | DP-based triple-loop distance update |

---

### 2. Questions to Ask Before You Code

1. Is the graph directed or undirected?    
2. Is it weighted or unweighted?
3. Are there negative weights? 
4. What representation should I use? (adjacency list/matrix)
5. Is the problem asking about:
    - Connectivity?
    - Shortest/Longest Path?
    - Cycles?
    - Components?
    - Topological order?

---

## 3. Must-Learn Problems by Pattern

|Problem|Pattern|Must-Learn Concept|
|---|---|---|
|1. Number of Islands|DFS / BFS|Traverse components in 2D grid|
|2. Clone Graph|DFS / BFS|Use hashmap to avoid revisits|
|3. Word Ladder|BFS|Shortest path on word transformation graph|
|4. Course Schedule I & II|Topological Sort|Detect cycle + get valid order (Kahn‚Äôs Algo)|
|5. Network Delay Time|Dijkstra‚Äôs|Min time using PQ on weighted graph|
|6. Cheapest Flights Within K Stops|BFS + Min Heap|Combine BFS layers with cost tracking|
|7. Detect Cycle in Undirected Graph|Union-Find|Same component? Then cycle exists|
|8. Graph Valid Tree|Union-Find / DFS|Check if connected + no cycle|
|9. Redundant Connection|Union-Find|Last edge forming a cycle|
|10. Critical Connections in Network|Tarjan‚Äôs Bridge|Discovery & Low link values|

---

## 4. Code Templates (Simplified)

üü¢ 1. BFS Template (Unweighted Shortest Path)

```cpp
queue<pair<int, int>> q; // node, distance
unordered_set<int> visited;

q.push({src, 0});
visited.insert(src);

while (!q.empty()) {
    auto [node, dist] = q.front(); q.pop();
    for (int nei : graph[node]) {
        if (!visited.count(nei)) {
            q.push({nei, dist + 1});
            visited.insert(nei);
        }
    }
}
```

üü° 2. DFS Template

```cpp
void dfs(int node, unordered_set<int>& visited) {
    visited.insert(node);
    for (int nei : graph[node]) {
        if (!visited.count(nei))
            dfs(nei, visited);
    }
}
```

üü† 3. Dijkstra‚Äôs Algorithm

```cpp
priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
vector<int> dist(n, INT_MAX);

pq.push({0, start});
dist[start] = 0;

while (!pq.empty()) {
    auto [d, node] = pq.top(); pq.pop();
    for (auto [nei, wt] : graph[node]) {
        if (dist[nei] > d + wt) {
            dist[nei] = d + wt;
            pq.push({dist[nei], nei});
        }
    }
}
```

üîµ 4. Topological Sort (Kahn‚Äôs Algorithm)

```cpp
vector<int> indegree(n, 0);
for (auto &[u, v] : edges) indegree[v]++;
queue<int> q;
for (int i = 0; i < n; ++i) if (indegree[i] == 0) q.push(i);

vector<int> topo;
while (!q.empty()) {
    int node = q.front(); q.pop();
    topo.push_back(node);
    for (int nei : graph[node]) {
        if (--indegree[nei] == 0) q.push(nei);
    }
}
```

üî¥ 5. Union-Find (DSU)

```cpp
vector<int> parent(n);
iota(parent.begin(), parent.end(), 0);

int find(int x) {
    return parent[x] == x ? x : parent[x] = find(parent[x]);
}

bool unite(int u, int v) {
    int pu = find(u), pv = find(v);
    if (pu == pv) return false;
    parent[pu] = pv;
    return true;
}
```

---

## 5. Weekly Plan ‚Äî Graphs from Basics to Advanced

üìÖ Week 1 ‚Äî Fundamentals

|Day|Task|
|---|---|
|Day 1|BFS/DFS: Number of Islands, Clone Graph|
|Day 2|Word Ladder + Nearest Exit in Maze|
|Day 3|Union-Find: Valid Tree, Redundant Connection|
|Day 4|Topological Sort: Course Schedule I & II|
|Day 5|Dijkstra‚Äôs: Network Delay Time, Cheapest Flights|
|Day 6|DFS + Tarjan‚Äôs: Bridges in Graph|
|Day 7|Recap all templates + Solve 3 unseen Leetcode Mediums|

---

## 6. Tips to Succeed in Graph Problems

‚úÖ Always draw small graph examples  
‚úÖ Choose the right representation: adj list is best for space  
‚úÖ For weighted graphs ‚Üí Think Dijkstra (no -ve), Bellman-Ford (yes -ve)  
‚úÖ Always use visited set/array to prevent infinite loops  
‚úÖ For topological sort ‚Üí Only DAGs work  
‚úÖ For DSU problems ‚Üí If ‚Äúcycle‚Äù, ‚Äúconnected components‚Äù mentioned, try Union-Find
