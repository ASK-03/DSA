## Step-By-Step Approach

Used heavily in parsing, range problems, and simulating sequences, these patterns form the base of many complex topics like Monotonic Stack, Sliding Window, Expression Evaluation, etc.

---

### 1. Learn These 6 Core Stack/Queue Patterns

| Pattern                   | Example Problem                         | Key Idea                                        |
| ------------------------- | --------------------------------------- | ----------------------------------------------- |
| 1. Monotonic Stack        | Next Greater Element, Largest Rectangle | Maintain increasing/decreasing stack of indices |
| 2. Sliding Window (Queue) | Max in Sliding Window                   | Maintain deque to track useful elements         |
| 3. Expression Parsing     | Basic Calculator I/II, Reverse Polish   | Stack for operators/numbers, handle precedence  |
| 4. Stack Simulation       | Valid Parentheses, Backspace Compare    | Push/pop to track state                         |
| 5. Queue Simulation       | Rotten Oranges, Walls & Gates           | BFS-style simulation using queue                |
| 6. Stack of Stacks        | Min Stack, Max Stack, Frequency Stack   | Use auxiliary stacks to store useful meta info  |

---

### 2. Questions to Ask Yourself

1. Is the input being consumed from front (queue) or end (stack)?    
2. Am I interested in previous/next greater/smaller elements?
3. Is the problem based on brackets, spans, or maintaining a range?
4. Am I doing BFS? â†’ Queue.  
    Am I doing DFS or simulating a call stack? â†’ Stack.

---

### 3. Must-Master Problems with Each Pattern

|Problem|Pattern|Must-Learn Idea|
|---|---|---|
|1. Valid Parentheses (LC 20)|Stack Simulation|Push matching open, pop on close|
|2. Backspace String Compare (LC 844)|Stack Simulation|Simulate final strings via stack|
|3. Min Stack (LC 155)|Stack of Stacks|Maintain stack of mins alongside values|
|4. Next Greater Element (LC 496)|Monotonic Stack|Traverse from right, maintain NGE stack|
|5. Largest Rectangle in Histogram|Monotonic Stack|Track boundaries with stack|
|6. Max in Sliding Window (LC 239)|Deque (Monotonic Q)|Store indices, pop smaller values|
|7. Daily Temperatures (LC 739)|Monotonic Stack|Store indices, check how many days ahead|
|8. Rotten Oranges (LC 994)|Queue Simulation|BFS level-order traversal|
|9. Open the Lock (LC 752)|BFS Queue|Shortest path with state traversal|
|10. Basic Calculator II (LC 227)|Stack Expression|Handle operator precedence via stack|

---

### 4. Key Templates You Must Know

1. Monotonic Stack (Next Greater Element)

```cpp
vector<int> nextGreater(vector<int>& nums) {
    stack<int> st;
    vector<int> res(nums.size(), -1);
    for (int i = nums.size() - 1; i >= 0; --i) {
        while (!st.empty() && st.top() <= nums[i])
            st.pop();
        if (!st.empty()) res[i] = st.top();
        st.push(nums[i]);
    }
    return res;
}
```

2. Sliding Window Maximum (Monotonic Deque)

```cpp
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    deque<int> dq;
    vector<int> res;
    for (int i = 0; i < nums.size(); ++i) {
        if (!dq.empty() && dq.front() == i - k) dq.pop_front();
        while (!dq.empty() && nums[dq.back()] < nums[i]) dq.pop_back();
        dq.push_back(i);
        if (i >= k - 1) res.push_back(nums[dq.front()]);
    }
    return res;
}
```

3. Stack-based Expression Evaluator

```cpp
int calculate(string s) {
    stack<int> stk;
    char op = '+';
    int num = 0;
    for (int i = 0; i < s.size(); ++i) {
        if (isdigit(s[i])) num = num * 10 + (s[i] - '0');
        if (!isdigit(s[i]) && s[i] != ' ' || i == s.size() - 1) {
            if (op == '+') stk.push(num);
            else if (op == '-') stk.push(-num);
            else if (op == '*') {
                int top = stk.top(); stk.pop();
                stk.push(top * num);
            } else if (op == '/') {
                int top = stk.top(); stk.pop();
                stk.push(top / num);
            }
            op = s[i];
            num = 0;
        }
    }
    int res = 0;
    while (!stk.empty()) res += stk.top(), stk.pop();
    return res;
}
```

4. BFS using Queue (Rotten Oranges)

```cpp
int orangesRotting(vector<vector<int>>& grid) {
    queue<pair<int,int>> q;
    int fresh = 0, time = 0;
    int dirs[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};

    for (int i = 0; i < grid.size(); ++i)
        for (int j = 0; j < grid[0].size(); ++j)
            if (grid[i][j] == 2) q.push({i, j});
            else if (grid[i][j] == 1) fresh++;

    while (!q.empty() && fresh) {
        int n = q.size();
        while (n--) {
            auto [x, y] = q.front(); q.pop();
            for (auto& d : dirs) {
                int nx = x + d[0], ny = y + d[1];
                if (nx >= 0 && ny >= 0 && nx < grid.size() && ny < grid[0].size()
                    && grid[nx][ny] == 1) {
                    grid[nx][ny] = 2;
                    q.push({nx, ny});
                    fresh--;
                }
            }
        }
        time++;
    }
    return fresh == 0 ? time : -1;
}
```

---

### 5. Mini Weekly Plan â€” Stack/Queue Fluency

ðŸ“… Week 1: Build Intuition by Pattern

|Day|Task|
|---|---|
|Day 1|Valid Parentheses + Min Stack|
|Day 2|Next Greater Element + Largest Rectangle|
|Day 3|Daily Temperatures + Asteroid Collision|
|Day 4|Sliding Window Maximum + Monotonic Deque|
|Day 5|BFS: Rotten Oranges + Open the Lock|
|Day 6|Basic Calculator I & II|
|Day 7|Recap templates and solve 3 unseen Leetcode Mediums using stacks/queues|

---

## 6. Tips for Success

âœ… Think about indices, not values, when using monotonic stacks/deques  
âœ… For sliding window problems, maintain only relevant elements (those still in the window and useful)  
âœ… Bracket validation â†’ always use stack  
âœ… For expression problems â†’ build the number, apply the operator when a new one arrives.
âœ… Use queue for any layer-based / BFS-style expansion problems

---

### 7. Problem Links
1. [Basic Calculator](https://leetcode.com/problems/basic-calculator/) ([My Solution With Notes](https://leetcode.com/problems/basic-calculator/submissions/1697721755))
2. [Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/)([My Solution With Notes](https://leetcode.com/problems/basic-calculator-ii/submissions/1697748610))
3. [Maximum Frequency Stack](https://leetcode.com/problems/maximum-frequency-stack/)
4. 