# Intervals

Interval problems are common in interviews (especially at Google, Facebook, and Uber). Mastering these helps with greedy, sorting, scheduling, and line sweep logic.

---

## Step-by-Step Breakdown: Intervals

---

## 1. Master the 4 Core Interval Patterns

| Pattern                  | Example Problem                   | Key Idea                                        |
| ------------------------ | --------------------------------- | ----------------------------------------------- |
| 1. Interval Merging      | Merge Intervals                   | Sort by start ‚Üí merge overlapping using a stack |
| 2. Line Sweep            | Meeting Rooms II, Min Arrows      | Convert to events, sort by time, use a counter  |
| 3. Difference Array      | Car Pooling, Flight Bookings      | Use prefix sums to process bulk range updates   |
| 4. Room/Platform Booking | Train Platforms, Calendar Booking | Track how many intervals overlap at once        |

---

## 2. Key Questions to Ask

1. Are intervals overlapping or touching?
2. Do I need to merge, count overlaps, or track max concurrent usage?
3. Is it more efficient to process events as ‚Äústart/end‚Äù?
4. Can sorting help reduce brute force comparisons?

üëâ If you're comparing pairwise ‚Üí Think about sorting first.

---

## 3. Must-Know Problems (and what to learn)

| Problem                      | Pattern           | Key Idea                                       |
| ---------------------------- | ----------------- | ---------------------------------------------- |
| 1. Merge Intervals           | Interval Merging  | Sort + extend current if overlapping           |
| 2. Insert Interval           | Interval Merging  | Merge while inserting into correct position    |
| 3. Meeting Rooms II          | Line Sweep / Heap | Count concurrent meetings via start/end events |
| 4. Minimum Number of Arrows  | Line Sweep        | Greedily shoot at overlap end                  |
| 5. Car Pooling               | Difference Array  | Increment seats taken over range               |
| 6. Corporate Flight Bookings | Difference Array  | Range += seats; prefix sum                     |
| 7. Train Platform Problem    | Room Booking      | Count max overlapping trains                   |
| 8. My Calendar I/II/III      | Room Booking      | Avoid booking overlaps using tree/map/heap     |
| 9. Range Addition            | Difference Array  | Efficient range update for large arrays        |
| 10. Employee Free Time       | Merge + Heap      | Flatten schedules, merge, find gaps            |

---

## 4. Code Templates You Must Master

üü© 1. Interval Merging (Merge Intervals)  

```cpp
vector<vector<int>> merge(vector<vector<int>>& intervals) {
    sort(intervals.begin(), intervals.end());
    vector<vector<int>> res;
    for (auto& curr : intervals) {
        if (res.empty() || res.back()[1] < curr[0]) {
            res.push_back(curr);
        } else {
            res.back()[1] = max(res.back()[1], curr[1]);
        }
    }
    return res;
}
```

üü© 2. Line Sweep (Meeting Rooms II)  

```cpp
int minMeetingRooms(vector<vector<int>>& intervals) {
    vector<int> start, end;
    for (auto& it : intervals) {
        start.push_back(it[0]);
        end.push_back(it[1]);
    }
    sort(start.begin(), start.end());
    sort(end.begin(), end.end());

    int rooms = 0, j = 0;
    for (int i = 0; i < intervals.size(); i++) {
        if (start[i] < end[j]) rooms++;
        else j++; // free up a room
    }
    return rooms;
}
```

üü© 3. Difference Array (Car Pooling)  

```cpp
bool carPooling(vector<vector<int>>& trips, int capacity) {
    vector<int> seats(1001, 0); // max location = 1000
    for (auto& t : trips) {
        seats[t[1]] += t[0];
        seats[t[2]] -= t[0];
    }
    int curr = 0;
    for (int x : seats) {
        curr += x;
        if (curr > capacity) return false;
    }
    return true;
}
```

üü© 4. Calendar Booking (MyCalendar I)  
C++:

```cpp
class MyCalendar {
    vector<pair<int, int>> books;
public:
    bool book(int start, int end) {
        for (auto& [s, e] : books)
            if (max(s, start) < min(e, end)) return false;
        books.push_back({start, end});
        return true;
    }
};
```

---

## 5. Mini Learning Plan

üìÖ Week 1 ‚Äî Build Intuition and Core Handling

|Day|Task|
|---|---|
|Day 1|Merge Intervals + Insert Interval|
|Day 2|Meeting Rooms I & II|
|Day 3|Minimum Arrows + Train Platforms|
|Day 4|Car Pooling + Flight Bookings|
|Day 5|MyCalendar I/II/III|
|Day 6|Range Addition + Difference Array Custom|
|Day 7|Reflect & Build Templates from Scratch|

---

## 6. Tips for Success

‚úÖ Always sort intervals by start time  
‚úÖ Use greedy logic when minimizing resources (arrows, platforms)  
‚úÖ Use prefix sum when large input and multiple range updates  
‚úÖ Sweep line pattern = Treat start/end as (+1/-1) events  
‚úÖ Check edge overlaps carefully: [s, e) vs [s, e]

---

Want to continue with Trees or Graphs next? Or should we go deeper into a tricky subpattern like Line Sweep?