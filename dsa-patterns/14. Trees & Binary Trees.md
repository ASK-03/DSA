## 1. Core Tree Patterns You Must Master

| Pattern                    | Example Problem               | Key Idea                                     |
| -------------------------- | ----------------------------- | -------------------------------------------- |
| 1. DFS Traversals          | Inorder, Preorder, Postorder  | Recursive or Stack-based traversal           |
| 2. Level Order Traversal   | BFS, Zigzag, Right View       | Use a queue with level tracking              |
| 3. Diameter of Tree        | Diameter of Binary Tree       | Track max depth + longest path via recursion |
| 4. Lowest Common Ancestor  | LCA of Binary Tree / BST      | Postorder logic or BST properties            |
| 5. Serialize / Deserialize | Convert Tree to String & back | Use preorder or level-order encoding         |

---

## 2. Always Ask These for Tree Problems

1. Is it a Binary Tree or BST? 
2. Do I need to traverse all nodes or stop early?
3. Whatâ€™s the traversal order required (pre, in, post)?
4. Am I reconstructing the tree, or finding properties?

---

## 3. Must-Know Problems by Pattern

| Problem                              | Pattern                | What You Learn                            |
| ------------------------------------ | ---------------------- | ----------------------------------------- |
| 1. Inorder Traversal (LC 94)         | DFS                    | Left â†’ Root â†’ Right                       |
| 2. Preorder / Postorder Traversal    | DFS                    | Root â†’ Left â†’ Right / Left â†’ Right â†’ Root |
| 3. Level Order Traversal (LC 102)    | BFS                    | Queue with level grouping                 |
| 4. Right Side View (LC 199)          | Modified Level Order   | Track last seen node at each level        |
| 5. Diameter of Binary Tree (LC 543)  | Height + DFS           | Max leftDepth + rightDepth                |
| 6. LCA of Binary Tree (LC 236)       | Postorder DFS          | Return node if found in left/right        |
| 7. LCA in BST (LC 235)               | BST properties         | Move left/right based on value            |
| 8. Serialize & Deserialize (LC 297)  | Preorder + Null Marker | Use delimiter-based encoding              |
| 9. Construct from Inorder & Preorder | Divide and Conquer     | Reconstruct tree via value-index matching |
| 10. Path Sum (LC 112/113)            | DFS + Backtracking     | Track path sum while traversing           |

---

## 4. Code Templates to Memorize

ðŸŸ© 1. Inorder / Preorder / Postorder Traversal (Recursive)  

```cpp
void inorder(TreeNode* root, vector<int>& res) {
    if (!root) return;
    inorder(root->left, res);
    res.push_back(root->val);
    inorder(root->right, res);
}
```

ðŸŸ© 2. Level Order Traversal (BFS)

```cpp
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> res;
    if (!root) return res;
    queue<TreeNode*> q;
    q.push(root);
    while (!q.empty()) {
        int size = q.size();
        vector<int> level;
        for (int i = 0; i < size; ++i) {
            TreeNode* node = q.front(); q.pop();
            level.push_back(node->val);
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        res.push_back(level);
    }
    return res;
}
```

ðŸŸ© 3. Diameter of Binary Tree

```cpp
int diameter = 0;
int dfs(TreeNode* node) {
    if (!node) return 0;
    int left = dfs(node->left);
    int right = dfs(node->right);
    diameter = max(diameter, left + right);
    return 1 + max(left, right);
}
int diameterOfBinaryTree(TreeNode* root) {
    dfs(root);
    return diameter;
}
```

ðŸŸ© 4. Lowest Common Ancestor (Generic Tree)

```cpp
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root || root == p || root == q) return root;
    TreeNode* left = lowestCommonAncestor(root->left, p, q);
    TreeNode* right = lowestCommonAncestor(root->right, p, q);
    if (left && right) return root;
    return left ? left : right;
}
```

ðŸŸ© 5. Serialize and Deserialize (Preorder with Nulls)

```cpp
// Serialize
void serialize(TreeNode* root, string& res) {
    if (!root) { res += "# "; return; }
    res += to_string(root->val) + " ";
    serialize(root->left, res);
    serialize(root->right, res);
}

// Deserialize
TreeNode* deserialize(istringstream& ss) {
    string val;
    ss >> val;
    if (val == "#") return nullptr;
    TreeNode* node = new TreeNode(stoi(val));
    node->left = deserialize(ss);
    node->right = deserialize(ss);
    return node;
}
```

---

## 5. Tree Practice Plan

ðŸ“… Week 1 â€” Fundamentals & Recursion

| Day   | Task                                     |
| ----- | ---------------------------------------- |
| Day 1 | Inorder, Preorder, Postorder Traversal   |
| Day 2 | Level Order + Zigzag + Right View        |
| Day 3 | Diameter of Binary Tree                  |
| Day 4 | Path Sum I & II                          |
| Day 5 | Lowest Common Ancestor (Tree + BST)      |
| Day 6 | Serialize & Deserialize (Preorder / BFS) |
| Day 7 | Construct Tree from Traversals           |

---

## 6. Tips for Tree Mastery

âœ… Always use recursive templates â†’ then convert to iterative if needed  
âœ… Draw the tree on paper â€” visualize traversal orders  
âœ… In LCA, use postorder because decisions depend on left/right subtree returns  
âœ… Use queues for level traversal & recursion for depth-first insights  
âœ… Use null markers when serializing trees
