## 1. Master the 4 Core BST Patterns

| Pattern                  | Example Problem  | Key Idea                                     |
| ------------------------ | ---------------- | -------------------------------------------- |
| 1. Insert/Delete/Search  | LC 700, 701, 450 | Standard recursion using BST rules           |
| 2. Kth Smallest/Largest  | LC 230, LC 703   | Inorder traversal or augmented BST (size)    |
| 3. Range Sum / Count     | LC 938, LC 1038  | Use BST bounds to prune unnecessary branches |
| 4. Convert to DLL / List | LC 426, LC 114   | Inorder traversal while connecting pointers  |

---

## 2. Ask These When Facing a BST Problem

1. Am I working with a Binary Search Tree (BST) or just Binary Tree?    
2. Do I need the nodes in sorted order (â†’ Inorder)?
3. Can I use BST property to prune branches?
4. Is this an online structure (â†’ need to maintain balance/size)?

---

## 3. Must-Know Problems by Pattern

| Problem                                | Pattern               | What You Learn                          |
| -------------------------------------- | --------------------- | --------------------------------------- |
| 1. Search in BST (LC 700)              | Basic Search          | Use value comparison to navigate        |
| 2. Insert into BST (LC 701)            | Basic Insert          | Recurse until insertion point           |
| 3. Delete Node in BST (LC 450)         | Basic Delete          | 3 cases: no child, 1 child, 2 children  |
| 4. Kth Smallest Element (LC 230)       | Inorder Traversal     | Count nodes while traversing            |
| 5. Range Sum BST (LC 938)              | BST Pruning           | Avoid traversing out-of-bound branches  |
| 6. BST to Greater Tree (LC 538/1038)   | Reverse Inorder       | Accumulate suffix sum in right-to-left  |
| 7. Convert BST to DLL (LC 426, LC 114) | Inorder with Pointers | Connect nodes while traversing          |
| 8. Trim BST (LC 669)                   | BST Pruning           | Skip subtrees outside range             |
| 9. Validate BST (LC 98)                | Validity Check        | Use min/max bounds or inorder check     |
| 10. Serialize BST                      | BST-Aware Encoding    | Only preorder needed to reconstruct BST |

---

## 4. Code Templates You Must Know

ðŸŸ© 1. Search in BST

```cpp
TreeNode* searchBST(TreeNode* root, int val) {
    if (!root || root->val == val) return root;
    return val < root->val ? searchBST(root->left, val) : searchBST(root->right, val);
}
```

ðŸŸ© 2. Insert into BST

```cpp
TreeNode* insertIntoBST(TreeNode* root, int val) {
    if (!root) return new TreeNode(val);
    if (val < root->val)
        root->left = insertIntoBST(root->left, val);
    else
        root->right = insertIntoBST(root->right, val);
    return root;
}
```

ðŸŸ© 3. Delete from BST

```cpp
TreeNode* deleteNode(TreeNode* root, int key) {
    if (!root) return nullptr;
    if (key < root->val)
        root->left = deleteNode(root->left, key);
    else if (key > root->val)
        root->right = deleteNode(root->right, key);
    else {
        if (!root->left) return root->right;
        if (!root->right) return root->left;
        TreeNode* minRight = root->right;
        while (minRight->left) minRight = minRight->left;
        root->val = minRight->val;
        root->right = deleteNode(root->right, root->val);
    }
    return root;
}
```

ðŸŸ© 4. Kth Smallest in BST

```cpp
int count = 0, result = -1;
void inorder(TreeNode* root, int k) {
    if (!root) return;
    inorder(root->left, k);
    count++;
    if (count == k) result = root->val;
    inorder(root->right, k);
}
int kthSmallest(TreeNode* root, int k) {
    inorder(root, k);
    return result;
}
```

ðŸŸ© 5. Range Sum in BST

```cpp
int rangeSumBST(TreeNode* root, int low, int high) {
    if (!root) return 0;
    if (root->val < low) return rangeSumBST(root->right, low, high);
    if (root->val > high) return rangeSumBST(root->left, low, high);
    return root->val + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);
}
```

ðŸŸ© 6. Convert BST to Doubly Linked List (Circular)  
(LC 426 â€” Binary Tree to Doubly Linked List)

```cpp
TreeNode *first = nullptr, *last = nullptr;
void helper(TreeNode* node) {
    if (!node) return;
    helper(node->left);
    if (last) {
        last->right = node;
        node->left = last;
    } else {
        first = node;
    }
    last = node;
    helper(node->right);
}

TreeNode* treeToDoublyList(TreeNode* root) {
    if (!root) return nullptr;
    helper(root);
    first->left = last;
    last->right = first;
    return first;
}
```

---

## 5. Weekly BST Practice Plan

ðŸ“… Week 1 â€” BST Core Patterns

| Day   | Task                                             |
| ----- | ------------------------------------------------ |
| Day 1 | Search / Insert / Delete                         |
| Day 2 | Kth Smallest + Count Nodes                       |
| Day 3 | Range Sum BST + Greater Tree                     |
| Day 4 | Convert to DLL (LC 426/114)                      |
| Day 5 | Trim BST + Validate BST                          |
| Day 6 | Build BST from Preorder                          |
| Day 7 | Write your own BST class (Insert, Delete, Print) |

---

## 6. Tips for Mastery

âœ… In BSTs: Left < Root < Right â†’ always remember  
âœ… For Kth node problems â†’ Think Inorder Traversal  
âœ… For range problems â†’ Prune with value bounds  
âœ… When deleting a node with 2 children â†’ Replace with inorder successor  
âœ… Always test edge cases: insert/delete root, min/max nodes

---
## 7. Questions
1. [Binary Tree to DLL](https://www.geeksforgeeks.org/problems/binary-tree-to-dll/1)
2. 