## Step-By-Step Approach
---

### 1. **Learn the 5 Major Binary Search Patterns**

|Pattern|Example Problem|Key Idea|
|---|---|---|
|1. Classic Search in Array|Binary Search, First/Last Position|Find index of target or its boundaries|
|2. Lower/Upper Bound|Insert Position, Floor/Ceil|Find first or last element satisfying condition|
|3. Search on Answer|Min Days to Make Bouquet|Binary search the **range of answer**, not array|
|4. Predicate Function Search|Koko Eating Bananas, Aggressive Cows|Use `isValid(x)` as your binary search checker|
|5. Bitonic/Rotated Array|Peak Element, Min in Rotated Array|Adapt BS on special patterns|

---

### 2. **Ask These 3 Questions Before Using Binary Search**

1. **Is the array/search space sorted or monotonic?**
2. **Am I looking for a boundary (first/last) or just existence?**
3. **Can I model the problem as “is x a valid answer?”**

---

### 3. **Must-Know Problems for Each Pattern**

|Problem|Pattern|Must-Learn Idea|
|---|---|---|
|1. Binary Search (LC 704)|Classic|Template 1|
|2. First/Last Position (LC 34)|Boundary Search|Find left/right bound using modified mid|
|3. Search Insert Position|Lower Bound|Insertion point = first `>= target`|
|4. Peak Element (LC 162)|Bitonic|Use mid comparison with neighbors|
|5. Min in Rotated Array (LC 153)|Rotated|Search smallest via mid vs right|
|6. Find in Rotated Sorted (LC 33)|Hybrid|Use mid and decide left/right side|
|7. Koko Eating Bananas|Search on Answer|Search over eating speed|
|8. Capacity to Ship Packages|Search on Answer|Use predicate: can ship in D days|
|9. Aggressive Cows (GFG)|Predicate Binary Search|Maximize minimum distance|
|10. Allocate Books|Binary Search on max load|Distribute with constraints|

---

### 4. **Code Templates You Must Remember**

#### 1. Classic Binary Search

```cpp
int binarySearch(vector<int>& arr, int target) {
    int low = 0, high = arr.size() - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) low = mid + 1;
        else high = mid - 1;
    }
    return -1;
}
```

#### 2. Lower/Upper Bound (First/Last Occurrence)

```cpp
// First occurrence of target
int findFirst(vector<int>& arr, int target) {
    int low = 0, high = arr.size() - 1, ans = -1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] >= target) {
            if (arr[mid] == target) ans = mid;
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return ans;
}
```

#### 3. Search on Answer / Predicate Check

```cpp
// Example: Min speed to finish in h hours
int minSpeed(vector<int>& piles, int h) {
    int low = 1, high = 1e9;
    auto canEat = [&](int speed) {
        long long time = 0;
        for (int p : piles) time += (p + speed - 1) / speed;
        return time <= h;
    };
    while (low < high) {
        int mid = low + (high - low) / 2;
        if (canEat(mid)) high = mid;
        else low = mid + 1;
    }
    return low;
}
```

---

### 5. **Mini Learning Plan for Binary Search**

#### 📅 Week 1 — Pattern Recognition

|Day|Task|
|---|---|
|Day 1|Binary Search + First/Last Occurrence|
|Day 2|Lower/Upper Bound + Insert Position|
|Day 3|Min in Rotated Array + Find in Rotated|
|Day 4|Peak Element + Bitonic Mountain Array|
|Day 5|Search on Answer: Koko Bananas + Capacity to Ship|
|Day 6|Predicate Problems: Aggressive Cows + Allocate Books|
|Day 7|Reflect & Build Templates from Scratch|

---

### 6. **Tips for Success**

✅ Start by **writing the mid formula cleanly**  
✅ Use **binary search even when array is not involved**, especially for **"minimum x to satisfy a condition"**  
✅ Don't confuse **while (low < high)** vs **while (low <= high)** — the former is used for "search on answer"  
✅ Know **when to use left-biased vs right-biased search**

---

### 7. Problem Links

[Hard]
1. [Kth Smallest Product of Two Sorted Arrays](https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays/)
2. 