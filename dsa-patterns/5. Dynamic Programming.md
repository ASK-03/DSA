## Step-By-Step Approach

---
### 1. **Master the 9 Core DP Patterns**

| Pattern                      | Example Problem                             | Key Idea                                                 |
| ---------------------------- | ------------------------------------------- | -------------------------------------------------------- |
| 1. 1D DP                     | Climbing Stairs, Fibonacci                  | Build `dp[i]` using `dp[i‚àí1]`, `dp[i‚àí2]`, etc.           |
| 2. 2D Grid DP                | Unique Paths, Min Path Sum                  | Use grid movement (i‚àí1,j), (i,j‚àí1) to build state        |
| 3. DP on Subsequences        | LCS, LIS, Edit Distance                     | Choices: include/exclude, match/mismatch                 |
| 4. DP with State Compression | House Robber, Max Sum Non-Adjacent          | Track only last few states (`prev`, `prev2`, etc.)       |
| 5. Knapsack Variants         | 0/1 Knapsack, Target Sum                    | Either pick or skip current item                         |
| 6. Bitmask DP                | TSP, Assignment Problem                     | Use bitmask to represent visited subset                  |
| 7. DP on Trees / Graphs      | Robber III, Longest Path in DAG             | Use postorder DFS and merge child states                 |
| 8. Digit DP                  | Count Numbers with Digit Constraints        | Build number digit-by-digit with tight & mask conditions |
| 9. DP with Gaps / Ranges     | Burst Balloons, Matrix Chain Multiplication | Try every partition (`k`) between `(i, j)`               |

---

### 2. **How to Recognize a DP Problem**

Ask these:

- ‚ùì Can I define a recursive solution with overlapping subproblems?
- üß± Can I define a `state` using index, sum, mask, or tight?
- üîÅ Is recursion giving TLE ‚Üí memoize it or try tabulation.
- üìè Is there optimal substructure?

---

### 3. **Must-Learn Problems by Pattern**

| Problem                           | Pattern           | Core Learning                                        |
| --------------------------------- | ----------------- | ---------------------------------------------------- |
| Fibonacci / Climbing Stairs       | 1D DP             | Recurrence relation: `f(n) = f(n-1) + f(n-2)`        |
| House Robber I/II                 | State Compression | Pick or skip; update max from prev2                  |
| Longest Increasing Subsequence    | Subsequences      | `dp[i] = 1 + max(dp[j]) if arr[j] < arr[i]`          |
| Longest Common Subsequence        | 2D DP             | Grid match/mismatch build                            |
| Edit Distance                     | 2D DP             | Insert/Delete/Replace choices                        |
| Unique Paths / Min Path Sum       | Grid DP           | `dp[i][j] = dp[i-1][j] + dp[i][j-1]`                 |
| Partition Equal Subset Sum        | Knapsack 0/1      | Can we make sum/2?                                   |
| Target Sum (LC 494)               | Knapsack Variant  | Use ¬± choices; similar to subset sum                 |
| TSP (LC 943, GFG)                 | Bitmask DP        | `dp[mask][i]` = min cost visiting mask ending at i   |
| Robber III (LC 337)               | Tree DP           | Postorder traversal, pick or skip child              |
| Count of Numbers with Digit Sum K | Digit DP          | Use digit index, tight flag, and digit sum as states |
| Burst Balloons                    | DP with Gaps      | Try all `k` in `(i+1 to j‚àí1)`                        |

---

### 4. **Templates You Must Know**

#### üìå Top-Down (Memoization)

```cpp
int dp[n][state];
int f(int i, int state) {
    if (base) return value;
    if (dp[i][state] != -1) return dp[i][state];

    return dp[i][state] = min/max(f(...), f(...));
}
```

#### üìå Bottom-Up (Tabulation)

```cpp
vector<int> dp(n+1, 0);
dp[0] = 1;
for (int i = 1; i <= n; ++i) {
    dp[i] = dp[i-1] + dp[i-2];
}
```

#### üìå 2D DP (Subsequence problems)

```cpp
vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
for (int i = 1; i <= m; ++i)
    for (int j = 1; j <= n; ++j)
        dp[i][j] = text1[i-1] == text2[j-1] ? 1 + dp[i-1][j-1]
                                            : max(dp[i-1][j], dp[i][j-1]);
```

#### üìå Knapsack-Style

```cpp
vector<vector<bool>> dp(n+1, vector<bool>(target+1, false));
dp[0][0] = true;
for (int i = 1; i <= n; ++i)
    for (int j = 0; j <= target; ++j)
        dp[i][j] = dp[i-1][j] || (j >= nums[i-1] && dp[i-1][j - nums[i-1]]);
```

#### üìå Bitmask DP (e.g. TSP)

```cpp
int dp[1<<n][n];
int f(int mask, int i) {
    if (mask == all_visited) return cost[i][0];
    if (dp[mask][i] != -1) return dp[mask][i];

    int ans = INT_MAX;
    for (int j = 0; j < n; j++)
        if (!(mask & (1<<j)))
            ans = min(ans, cost[i][j] + f(mask | (1<<j), j));
    return dp[mask][i] = ans;
}
```

#### üìå Digit DP

```cpp
int dp[pos][sum][tight];
int f(int pos, int sum, bool tight, vector<int>& digits) {
    if (pos == digits.size()) return sum == 0;
    if (dp[pos][sum][tight] != -1) return dp[pos][sum][tight];

    int limit = tight ? digits[pos] : 9;
    int ans = 0;
    for (int d = 0; d <= limit; d++)
        ans += f(pos+1, sum-d, tight && (d==limit), digits);
    return dp[pos][sum][tight] = ans;
}
```

---

### 5. üìÖ Mini Plan to Master DP

#### Week 1 ‚Äî Foundation

|Day|Focus|
|---|---|
|Day 1|Fibonacci, Climbing Stairs|
|Day 2|House Robber + State Compression|
|Day 3|LIS (n¬≤ and n log n)|
|Day 4|LCS + Edit Distance|
|Day 5|Grid DP: Unique Paths, Min Path Sum|
|Day 6|Knapsack: Partition + Target Sum|
|Day 7|Reflect and Recurrence Sheet|

#### Week 2 ‚Äî Advanced

|Day|Focus|
|---|---|
|Day 8|Bitmask DP: TSP, Job Assignment|
|Day 9|Tree DP: Robber III, DP on Subtrees|
|Day 10|Decode Ways, Paint House, Friends Pairing|
|Day 11|Palindromic Substrings, DP for Palindrome Partition|
|Day 12|DP with Ranges: Burst Balloons|
|Day 13|**Digit DP**: Count numbers with digit constraints|
|Day 14|Write your own templates from scratch|

---

### 6. ‚úÖ Tips for Success

- Clearly define `state`, `transition`, and `base cases`.
- Try recursion first ‚Üí then optimize to DP.
- For 2D/3D DP, draw out the grid/table to visualize transitions.
- Optimize space using state compression where possible.
- Build a personal ‚ÄúDP Template Sheet‚Äù from problems you solve.

---

### üîó Problem Practice Links

1. [Fibonacci / Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)
2. [Unique Paths I/II](https://leetcode.com/problems/unique-paths-ii/)
3. [Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)
4. [Longest Common Subsequence](https://www.geeksforgeeks.org/problems/longest-common-subsequence-1587115620/1)
5. [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)
6. [House Robber I](https://leetcode.com/problems/house-robber/)
7. [Max Sum without Adjacents](https://www.geeksforgeeks.org/problems/max-sum-without-adjacents2430/1)
8. [0/1 Knapsack](https://www.geeksforgeeks.org/problems/0-1-knapsack-problem0945/1)
9. [Target Sum (LC 494)](https://leetcode.com/problems/target-sum/)
10. [TSP (Bitmask)](https://www.geeksforgeeks.org/problems/travelling-salesman-problem2732/1)
11. [Robber III (Tree DP)](https://leetcode.com/problems/house-robber-iii/)
12. [More Question on DP on Tree & Graphs](https://leetcode.com/problem-list/50v8rtm7/)
13. [Burst Balloons](https://leetcode.com/problems/burst-balloons/)
14. [Digit DP Practice (Sum of Digits)](https://atcoder.jp/contests/abc154/tasks/abc154_e

#### Hard Problems
1. [The Earliest and Latest Rounds Where Players Compete](https://leetcode.com/problems/the-earliest-and-latest-rounds-where-players-compete/)

---