# Heaps & Priority Queues

Heaps are powerful tools for problems where you constantly need the ‚Äúbest‚Äù or ‚Äúworst‚Äù element efficiently ‚Äî like top k, sorting, merging, and greedy selection.

---

## Step-by-Step Approach

---

## 1. Core Heap Patterns You Must Know

|Pattern|Example Problem|Key Idea|
|---|---|---|
|1. Top K Elements|Top K Frequent Elements|Use Min/Max Heap of size k|
|2. Running Median|Median of Data Stream|Use two heaps (min + max) to maintain halves|
|3. K-Way Merge|Merge K Sorted Lists|Min Heap of head elements across sorted lists|
|4. Greedy with Heap|Huffman Coding, Dijkstra|Pick smallest/largest repeatedly using heap|
|5. Custom Sort Logic|Reorganize String, Task Scheduler|Heap based on frequency or priority|
|6. Sliding Window Problems|Max in Sliding Window|Monotonic Queue or Max-Heap with lazy deletion|

---

## 2. Ask These Questions for Heap Usage

1. Do I need to always get the top smallest/largest/frequent element?
2. Do I need to merge multiple streams while preserving order?
3. Is the dataset too large to fully sort?
4. Is the problem greedy in nature?

If yes ‚Üí Heap is likely useful.

---

## 3. Must-Know Problems by Pattern

| Problem                         | Pattern           | Must-Learn Idea                              |
| ------------------------------- | ----------------- | -------------------------------------------- |
| 1. Kth Largest Element in Array | Top K             | Maintain Min Heap of size k                  |
| 2. Top K Frequent Elements      | Top K             | Count freq + Min Heap of pairs               |
| 3. K Closest Points to Origin   | Top K             | Max Heap by distance                         |
| 4. Median of Data Stream        | Running Median    | Two heaps: maxHeap (left), minHeap (right)   |
| 5. Merge K Sorted Lists         | K-way Merge       | Min Heap with (val, list index)              |
| 6. Reorganize String            | Custom Sort       | Max Heap on frequency                        |
| 7. Task Scheduler               | Custom Sort       | Max Heap + cooldown queue                    |
| 8. Huffman Encoding             | Greedy with Heap  | Combine smallest freq trees                  |
| 9. Dijkstra‚Äôs Algorithm         | Greedy with Heap  | Min Heap with (distance, node)               |
| 10. Sliding Window Maximum      | Heap or Monoqueue | Maintain max over window using heap or deque |

---

## 4. Code Templates to Memorize

### 1. Top K using Min Heap

```cpp
priority_queue<int, vector<int>, greater<int>> pq;
for (int num : nums) {
    pq.push(num);
    if (pq.size() > k) pq.pop(); // Maintain only k elements
}
return pq.top(); // Kth largest
```

### 2. Running Median (Two Heaps)

```cpp
priority_queue<int> left; // Max heap
priority_queue<int, vector<int>, greater<int>> right; // Min heap

void addNum(int num) {
    if (left.empty() || num <= left.top()) left.push(num);
    else right.push(num);

    // Balance heaps
    if (left.size() > right.size() + 1) {
        right.push(left.top()); left.pop();
    } else if (right.size() > left.size()) {
        left.push(right.top()); right.pop();
    }
}

double findMedian() {
    if (left.size() == right.size()) return (left.top() + right.top()) / 2.0;
    return left.top();
}
```

### 3. K-Way Merge of Sorted Lists

```cpp
auto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; };
priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp);

for (auto list : lists) if (list) pq.push(list);

ListNode dummy, *tail = &dummy;
while (!pq.empty()) {
    ListNode* node = pq.top(); pq.pop();
    tail->next = node; tail = node;
    if (node->next) pq.push(node->next);
}
return dummy.next;
```

---

## 5. Weekly Practice Plan

üìÖ Week 1 ‚Äî Core Concepts and Standard Uses

| Day   | Task                                                  |
| ----- | ----------------------------------------------------- |
| Day 1 | Kth Largest in Array + Top K Frequent Elements        |
| Day 2 | K Closest Points to Origin + Reorganize String        |
| Day 3 | Median of Data Stream                                 |
| Day 4 | Merge K Sorted Lists                                  |
| Day 5 | Task Scheduler + Huffman Encoding                     |
| Day 6 | Dijkstra‚Äôs Algorithm + Minimum Cost to Connect Sticks |
| Day 7 | Review & Build Custom Priority Queue Classes          |

---

## 6. Tips for Success

‚úÖ Always remember:
- Min Heap in C++: priority_queue<int, vector, greater>    
- For custom types, define struct + operator< or use lambda
‚úÖ Think of heap as: ‚ÄúGive me best available option in O(log n)‚Äù
‚úÖ Use hash maps with heap for frequency-based problems (e.g. Top K Frequent)
‚úÖ Use two heaps for problems needing balancing (e.g. Running Median)